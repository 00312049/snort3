/* $Id: encode.h,v 1.22 2013-07-10 19:27:54 twease Exp $ */
/****************************************************************************
 *
 * Copyright (C) 2005-2013 Sourcefire, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License Version 2 as
 * published by the Free Software Foundation.  You may not use, modify or
 * distribute this program under any other version of the GNU General
 * Public License.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 ****************************************************************************/

// @file    encode.h
// @author  Russ Combs <rcombs@sourcefire.com>

#ifndef ENCODE_H
#define ENCODE_H

#include "decode.h"
#include "src/network_inspectors/stream5/stream_api.h"


extern Packet *encode_pkt;
extern uint64_t total_rebuilt_pkts;


typedef enum class {
    ENC_TCP_FIN,  ENC_TCP_RST,
    ENC_UNR_NET,  ENC_UNR_HOST,
    ENC_UNR_PORT, ENC_UNR_FW,
    ENC_TCP_PUSH,
    ENC_MAX
} EncodeType;

#define ENC_FLAG_FWD 0x80000000  // send in forward direction
#define ENC_FLAG_SEQ 0x40000000  // VAL bits contain seq adj
#define ENC_FLAG_ID  0x20000000  // use randomized IP ID
#define ENC_FLAG_NET 0x10000000  // stop after innermost network (ip4/6) layer
#define ENC_FLAG_DEF 0x08000000  // stop before innermost ip4 opts or ip6 frag header
#define ENC_FLAG_RAW 0x04000000  // don't encode outer eth header (this is raw ip)
#define ENC_FLAG_RES 0x03000000  // bits reserved for future use
#define ENC_FLAG_VAL 0x00FFFFFF  // bits for adjusting seq and/or ack

typedef uint32_t EncodeFlags;

// orig must be the current packet from the interface to
//   ensure proper encoding (not the reassembled packet).
// len is number of bytes in the encoded packet upon return
//   (or 0 if the returned pointer is null).
const uint8_t* Encode_Reject(
    EncodeType, EncodeFlags, const Packet* orig, uint32_t* len);

const uint8_t* Encode_Response(
    EncodeType, EncodeFlags, const Packet* orig, uint32_t* len,
    const uint8_t* payLoad, uint32_t payLen);

// allocate a Packet for later formatting (cloning)
Packet* Encode_New(void);

// release the allocated Packet
void Encode_Delete(Packet*);

// orig is the wire pkt; clone was obtained with New()
int Encode_Format(
    EncodeFlags, const Packet* orig, Packet* clone, PseudoPacketType);

#ifdef HAVE_DAQ_ADDRESS_SPACE_ID
int Encode_Format_With_DAQ_Info (
    EncodeFlags f, const Packet* p, Packet* c, PseudoPacketType type,
    const DAQ_PktHdr_t*, uint32_t opaque);

#elif defined(HAVE_DAQ_ACQUIRE_WITH_META)
int Encode_Format_With_DAQ_Info (
    EncodeFlags f, const Packet* p, Packet* c, PseudoPacketType type,
    uint32_t opaque);
#endif

// update length and checksum fields in layers and caplen, etc.
void Encode_Update(Packet*);

// Set the destination MAC address
void Encode_SetDstMAC(uint8_t* );


static inline void Encode_SetPkt(Packet* p)
{
    encode_pkt = p;
}

static inline Packet* Encode_GetPkt(void)
{
    return encode_pkt;
}

static inline void Encode_Reset(void)
{
    Encode_SetPkt(NULL);
}

static inline void UpdateRebuiltPktCount(void)
{
    total_rebuilt_pkts++;
}

static inline uint64_t GetRebuiltPktCount(void)
{
    return total_rebuilt_pkts;
}


/**
 * A D D E D   S T U F F
 */

typedef enum class _EncStatus {
    ENC_OK, ENC_BAD_PROTO, ENC_BAD_OPT, ENC_OVERFLOW
} EncStatus;

//-------------------------------------------------------------------------
// encoders operate layer by layer:
// * base+off is start of packet
// * base+end is start of current layer
// * base+size-1 is last byte of packet (in) / buffer (out)


struct blob;
typedef struct blob Buffer;
struct rand_handle;
typedef struct rand_handle rand_t;


typedef struct _EncState{
    EncodeType type;
    EncodeFlags flags;

    uint8_t layer;
    const Packet* p;
    uint16_t ip_len;
    uint8_t* ip_hdr;

    const uint8_t* payLoad;
    uint32_t payLen;
    uint8_t proto;

} EncState;

// all layer encoders look like this:
typedef EncStatus (*Encoder)(EncState*, Buffer* in, Buffer* out);
typedef EncStatus (*Updater)(Packet*, Layer*, uint32_t* len);
typedef void (*Formatter)(EncodeFlags, const Packet* p, Packet* c, Layer*);
// TBD implement other encoder functions

typedef struct {
    Encoder fencode;
    Updater fupdate;
    Formatter fformat;
} EncoderFunctions;


//-------------------------------------------------------------------------
// the if in UPDATE_BOUND can be defined out after testing because:
// 1. the packet was already decoded in decode.c so is structurally sound; and
// 2. encode takes at most the same space as decode.
#define UPDATE_BOUND(buf, n) \
    buf->end += n; \
    if ( buf->end > buf->size ) \
        return EncStatus::ENC_OVERFLOW


// previously static function

#define MIN_TTL             64
#define MAX_TTL            255

#define ICMP_UNREACH_DATA    8  // (per RFC 792)

#define FORWARD(e) (e->flags & ENC_FLAG_FWD)
#define REVERSE(f) (!(f & ENC_FLAG_FWD))

#define GET_IP_HDR_LEN(h) (((h)->ip_verhl & 0x0f) << 2)
#define GET_TCP_HDR_LEN(h) (((h)->th_offx2 & 0xf0) >> 2)
#define SET_TCP_HDR_LEN(h, n) (h)->th_offx2 = ((n << 2) & 0xF0)


// Get the buffer length for a given protocol
#define BUFF_DIFF(buf, ho) ((uint8_t*)(buf->base+buf->end)-(uint8_t*)ho)
    

PROTO_ID NextEncoder (EncState* );
uint8_t *Encode_GetDstMAC();


//-------------------------------------------------------------------------
// ttl considerations:
//
// we try to use the TTL captured for the session by the stream preprocessor
// when the session started.  if that is not available, we use the current
// TTL for forward packets and use (maximum - current) TTL for reverse
// packets.
//
// the reason we don't just force ttl to 255 (max) is to make it look a
// little more authentic.
//
// for reference, flexresp used a const rand >= 64 in both directions (the
// number was determined at startup and never changed); flexresp2 used the
// next higher multiple of 64 in both directions; and react used a const
// 64 in both directions.
//
// note that the ip6 hop limit field is entirely equivalent to the ip4 TTL.
// hop limit is in fact a more accurrate name for the actual usage of this
// field.
//-------------------------------------------------------------------------

static inline uint8_t GetTTL (const EncState* enc)
{
    char dir;
    uint8_t ttl;
    int outer = !enc->ip_hdr;

    if ( !enc->p->flow )
        return 0;

    if ( enc->p->packet_flags & PKT_FROM_CLIENT )
        dir = FORWARD(enc) ? SSN_DIR_CLIENT : SSN_DIR_SERVER;
    else
        dir = FORWARD(enc) ? SSN_DIR_SERVER : SSN_DIR_CLIENT;

    // outermost ip is considered to be outer here,
    // even if it is the only ip layer ...
    ttl = stream.get_session_ttl(enc->p->flow, dir, outer);

    // so if we don't get outer, we use inner
    if ( 0 == ttl && outer )
        ttl = stream.get_session_ttl(enc->p->flow, dir, 0);

    return ttl;
}



static inline uint8_t FwdTTL (const EncState* enc, uint8_t ttl)
{
    uint8_t new_ttl = GetTTL(enc);
    if ( !new_ttl )
        new_ttl = ttl;
    return new_ttl;
}

static inline uint8_t RevTTL (const EncState* enc, uint8_t ttl)
{
    uint8_t new_ttl = GetTTL(enc);
    if ( !new_ttl )
        new_ttl = ( MAX_TTL - ttl );
    if ( new_ttl < MIN_TTL )
        new_ttl = MIN_TTL;
    return new_ttl;
}



#endif

